{"version":3,"file":"WebChannel.js","sources":["../../src/channel/WebChannel.js"],"sourcesContent":["// SPDX-License-Identifier: Apache-2.0\nimport { ALL_WEB_NETWORK_NODES } from \"../constants/ClientConstants.js\";\nimport GrpcServiceError from \"../grpc/GrpcServiceError.js\";\nimport GrpcStatus from \"../grpc/GrpcStatus.js\";\nimport HttpError from \"../http/HttpError.js\";\nimport HttpStatus from \"../http/HttpStatus.js\";\nimport { SDK_NAME, SDK_VERSION } from \"../version.js\";\nimport Channel, { encodeRequest, decodeUnaryResponse } from \"./Channel.js\";\n\nexport default class WebChannel extends Channel {\n    /**\n     * @param {string} address\n     */\n    constructor(address) {\n        super();\n\n        /**\n         * @type {string}\n         * @private\n         */\n        this._address = address;\n    }\n\n    /**\n     * @override\n     * @returns {void}\n     */\n    close() {\n        // do nothing\n    }\n\n    /**\n     * @override\n     * @protected\n     * @param {string} serviceName\n     * @returns {import(\"protobufjs\").RPCImpl}\n     */\n    _createUnaryClient(serviceName) {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        return async (method, requestData, callback) => {\n            try {\n                // Check if address already contains a scheme\n                const hasScheme =\n                    this._address.startsWith(\"http://\") ||\n                    this._address.startsWith(\"https://\");\n\n                let address;\n                if (hasScheme) {\n                    // Use the address as-is if it already has a scheme\n                    address = this._address;\n                } else {\n                    // Only prepend scheme if none exists\n                    const shouldUseHttps = !(\n                        this._address.includes(\"localhost\") ||\n                        this._address.includes(\"127.0.0.1\")\n                    );\n\n                    address = shouldUseHttps\n                        ? `https://${this._address}`\n                        : `http://${this._address}`;\n                }\n                // this will be executed in a browser environment so eslint is\n                // disabled for the fetch call\n                //eslint-disable-next-line n/no-unsupported-features/node-builtins\n                const response = await fetch(\n                    `${address}/proto.${serviceName}/${method.name}`,\n                    {\n                        method: \"POST\",\n                        headers: {\n                            \"content-type\": \"application/grpc-web+proto\",\n                            \"x-user-agent\": `${SDK_NAME}/${SDK_VERSION}`,\n                            \"x-grpc-web\": \"1\",\n                        },\n                        body: encodeRequest(requestData),\n                    },\n                );\n\n                if (!response.ok) {\n                    const error = new HttpError(\n                        HttpStatus._fromValue(response.status),\n                    );\n                    callback(error, null);\n                }\n\n                // Check headers for gRPC errors\n                const grpcStatus = response.headers.get(\"grpc-status\");\n                const grpcMessage = response.headers.get(\"grpc-message\");\n\n                if (grpcStatus != null && grpcMessage != null) {\n                    const error = new GrpcServiceError(\n                        GrpcStatus._fromValue(parseInt(grpcStatus)),\n                        ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n                    );\n                    error.message = grpcMessage;\n                    callback(error, null);\n                }\n\n                const responseBuffer = await response.arrayBuffer();\n                const unaryResponse = decodeUnaryResponse(responseBuffer);\n\n                callback(null, unaryResponse);\n            } catch (error) {\n                const err = new GrpcServiceError(\n                    // retry on grpc web errors\n                    GrpcStatus._fromValue(18),\n                    ALL_WEB_NETWORK_NODES?.[this._address]?.toString(),\n                );\n                callback(err, null);\n            }\n        };\n    }\n}\n"],"names":["WebChannel","Channel","constructor","address","super","this","_address","close","_createUnaryClient","serviceName","async","method","requestData","callback","startsWith","includes","response","fetch","name","headers","SDK_NAME","SDK_VERSION","body","encodeRequest","ok","HttpError","HttpStatus","_fromValue","status","grpcStatus","get","grpcMessage","error","GrpcServiceError","GrpcStatus","parseInt","ALL_WEB_NETWORK_NODES","toString","message","responseBuffer","arrayBuffer","decodeUnaryResponse"],"mappings":"oWASe,MAAMA,UAAmBC,EAIpC,WAAAC,CAAYC,GACRC,QAMAC,KAAKC,SAAWH,CACxB,CAMI,KAAAI,GAEJ,CAQI,kBAAAC,CAAmBC,GAEf,OAAOC,MAAOC,EAAQC,EAAaC,KAC/B,IAMI,IAAIV,EACJ,GAJIE,KAAKC,SAASQ,WAAW,YACzBT,KAAKC,SAASQ,WAAW,YAKzBX,EAAUE,KAAKC,aACZ,CAOHH,IAJIE,KAAKC,SAASS,SAAS,cACvBV,KAAKC,SAASS,SAAS,cAIrB,WAAWV,KAAKC,WAChB,UAAUD,KAAKC,UACzC,CAIgB,MAAMU,QAAiBC,MACnB,GAAGd,WAAiBM,KAAeE,EAAOO,OAC1C,CACIP,OAAQ,OACRQ,QAAS,CACL,eAAgB,6BAChB,eAAgB,GAAGC,KAAYC,IAC/B,aAAc,KAElBC,KAAMC,EAAcX,KAI5B,IAAKI,EAASQ,GAAI,CAIdX,EAHc,IAAIY,EACdC,EAAWC,WAAWX,EAASY,SAEnB,KACpC,CAGgB,MAAMC,EAAab,EAASG,QAAQW,IAAI,eAClCC,EAAcf,EAASG,QAAQW,IAAI,gBAEzC,GAAkB,MAAdD,GAAqC,MAAfE,EAAqB,CAC3C,MAAMC,EAAQ,IAAIC,EACdC,EAAWP,WAAWQ,SAASN,IAC/BO,IAAwB/B,KAAKC,WAAW+B,YAE5CL,EAAMM,QAAUP,EAChBlB,EAASmB,EAAO,KACpC,CAEgB,MAAMO,QAAuBvB,EAASwB,cAGtC3B,EAAS,KAFa4B,EAAoBF,GAG7C,CAAC,MAAOP,GAMLnB,EALY,IAAIoB,EAEZC,EAAWP,WAAW,IACtBS,IAAwB/B,KAAKC,WAAW+B,YAE9B,KAC9B,EAEA"}